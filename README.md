# FT2BDD
FT2BDD stands for Fault Tree to BDD. It is a framework in which both fault trees and BDDs can be defined. To transform fault trees into BDDS we need variable orderings. The goal is to find an efficient variable ordering such that the construction of the BDD is as fast as possible (and the resulting BDD is as small as possible). Details on implementing new orderings or gates can be found in the documentation in the code. 

## Fault Trees
Fault trees are defined using gates (instances of the `Gate` class). The topmost gate defines the system, we also call it the system. When creating a new instance of the `FaultTree` class, this system should be given, as well as a name for the system. 
### Readers
A fault tree can also be created using a reader, currently, we only have a reader for the Galileo format (`GalileoReader`). 

## BDDs
BDDs (Binary Decision Diagrams) are representations for boolean functions. We can transform fault trees into BDDs. To do this we use the `BDDConstructor` class. This class also default minimises the created BDD using the `BDDMinimiser` class. The `BDDConstructor` also takes an instance of the `Ordering` class.

### Variable Orderings
Variable orderings are needed to transform fault trees into BDDs. Variable orderings can be created by creating a new class that inherits the `Ordering` class. Currently, we have the following orderings: 
1. `ManualOrdering`: to manually order variables,
2. `RandomOrdering`: to randomly order variables,
3. `SubTreeComplexityOrdering`: to order variables in the order of how impactful they are in the system,
4. `BFSOrdering`: to order variables based on how deep they are in the system (can be reversed).

## Analysis
To do analysis on the different components of the framework, there are some classes defined. First off, we have the `BDDAnalyser` class. This - for now - is a simple class that can calculate the number of nodes and edges in a BDD. 

The second analysis class is the `BDDBenchmark` class. This is a more powerful class that benchmarks a given file or fault tree with a number of orderings (you can give a list of orderings you want to benchmark). The results can either be given textually or as a graph generated by `matplotlib`. 

## Pretty Printing
Fault trees and BDDs can be pretty printed.
### Required packages
  - networkx (To correctly draw BDDs, we specifically need [this](https://github.com/networkx/networkx/commit/d883a19b5278f4fb1013dd16bb178b9be5b7cc64) commit, which is not in the current version. To work around this, install the development version).
 - matplotlib
 - pygraphviz (on Windows this is easiest by using Anaconda or MiniConda)

### Definition
Trees defined here are pretty printable. To do so, use the `PrettyPrintFaultTree` or the `PrettyPrintBDD` class. These classes are based on an abstract `_PrettyPrint` class. The only use for the abstract class is to define the functions `print_to_window` and `print_to_file`. These functions print the result to a window or to a file respectively. This is done by calling the related `matplotlib` functions. This means that the actual functions that prepare the graphs for printing should prepare the results using `matplotlib`. This is what the `_pretty_print` function should do. 
